# Отчет по лабораторной работе №1
# Введение в алгоритмы. Сложность. Поиск

- **Дата:** 2025-11-23
- **Семестр:** 3 курс 1 полугодие - 5 семестр
- **Группа:** ПИЖ-б-о-23-2(2)
- **Дисциплина:** Анализ сложности алгоритмов
- **Студент:** Урусов Руслан Исламович 
---

## Цель работы
Освоить понятие вычислительной сложности алгоритма. Получить практические навыки реализации и анализа линейного и бинарного поиска. Экспериментально подтвердить теоретические оценки сложности O(n) и O(log n).

---

## Теоретическая часть
Алгоритмическая сложность характеризует количество ресурсов (времени и памяти), необходимых алгоритму для обработки входных данных размера *n*.

- **Асимптотический анализ** — анализ поведения алгоритма при *n → ∞*, что позволяет абстрагироваться от аппаратных особенностей и констант.
- **O-нотация** («О-большое») — верхняя асимптотическая оценка роста функции, описывающая наихудший сценарий работы алгоритма.
- **Линейный поиск (Linear Search)** — последовательный перебор всех элементов массива до нахождения целевого значения. Сложность: **O(n)**.
- **Бинарный поиск (Binary Search)** — поиск элемента в отсортированном массиве путём деления интервала поиска пополам. Сложность: **O(log n)**. Требует предварительной сортировки массива.

---

## Практическая часть

### Выполненные задачи
1. Реализовать функцию линейного поиска элемента в массиве.
2. Реализовать функцию бинарного поиска элемента в отсортированном массиве.
3. Провести теоретический анализ сложности обоих алгоритмов.
4. Экспериментально сравнить время выполнения алгоритмов на массивах разного размера.
5. Визуализировать результаты, подтвердив асимптотику O(n) и O(log n).

---

### Ключевые фрагменты кода
```python
def linear_search(arr: List[int], target: int) -> Optional[int]:
    """
    Линейный поиск элемента в массиве.

    Args:
        arr: Массив для поиска
        target: Искомый элемент

    Returns:
        Индекс элемента или None если не найден
    """
    for i in range(len(arr)):  # O(n) - цикл по всем элементам
        if arr[i] == target:  # O(1) - сравнение
            return i  # O(1) - возврат результата
    return None  # O(1) - возврат None
    # Общая сложность: O(n)


def binary_search(arr: List[int], target: int) -> Optional[int]:
    """
    Бинарный поиск элемента в отсортированном массиве.

    Args:
        arr: Отсортированный массив
        target: Искомый элемент

    Returns:
        Индекс элемента или None если не найден
    """
    left = 0  # O(1) - инициализация
    right = len(arr) - 1  # O(1) - инициализация

    while left <= right:  # O(log n) -  уменьшает диапазон в 2 раза на шаг
        mid = (left + right) // 2  # O(1) - вычисление середины
        if arr[mid] == target:  # O(1) - сравнение
            return mid  # O(1) - возврат результата
        elif arr[mid] < target:  # O(1) - сравнение
            left = mid + 1  # O(1) - обновление левой границы
        else:
            right = mid - 1  # O(1) - обновление правой границы

    return None  # O(1) - возврат None
    # Общая сложность: O(log n)

```

---

## Результаты выполнения

### Характеристики ПК для тестирования
```
    - Процессор: Intel Core i7-1165G7 @ 2.80GHz
    - Оперативная память: 16 GB DDR4
    - ОС: Windows 10
    - Python: 3.13
```

### Экспериментальные данные
```bash
Размер массива | Linear (ms) | Binary (ms)
----------------------------------------
Тестирование размера 1000...
  Линейный поиск: 0.00003176 сек
  Бинарный поиск: 0.00000120 сек
Тестирование размера 2000...
  Линейный поиск: 0.00020053 сек
  Бинарный поиск: 0.00000411 сек
Тестирование размера 5000...
  Линейный поиск: 0.00047991 сек
  Бинарный поиск: 0.00000329 сек
Тестирование размера 10000...
  Линейный поиск: 0.00071152 сек
  Бинарный поиск: 0.00000325 сек
Тестирование размера 20000...
  Линейный поиск: 0.00109824 сек
  Бинарный поиск: 0.00000227 сек
Тестирование размера 50000...
  Линейный поиск: 0.00593425 сек
  Бинарный поиск: 0.00000526 сек
Тестирование размера 100000...
  Линейный поиск: 0.00769390 сек
  Бинарный поиск: 0.00000271 сек
Тестирование размера 200000...
  Линейный поиск: 0.02120470 сек
  Бинарный поиск: 0.00000329 сек
Тестирование размера 500000...
  Линейный поиск: 0.07812537 сек
  Бинарный поиск: 0.00001196 сек
Тестирование размера 1000000...
  Линейный поиск: 0.19829873 сек
  Бинарный поиск: 0.00000500 сек
```


### Тестирование
- Замеры времени проведены на массивах от 1000 до 1000000 элементов.

---

## Выводы
Эксперимент подтвердил теоретические оценки сложности; небольшие расхождения связаны с влиянием констант, особенностями Python и архитектуры ПК.  

---

## Ответы на контрольные вопросы
1. **Что такое асимптотическая сложность алгоритма и зачем она нужна?:**
- Асимптотическая сложность - это оценка роста времени выполнения или потребления памяти алгоритма при увеличении объема входных данных. Она нужна для сравнения алгоритмов независимо от аппаратного обеспечения и предсказания их поведения на больших данных.

2. **Объясните разницу между O(1), O(n) и O(log n). Приведите примеры алгоритмов с такой сложностью.**
- O(1) - постоянная сложность (доступ к элементу массива по индексу)
- O(n) - линейная сложность (линейный поиск, нахождение максимума в массиве)
- O(log n) - логарифмическая сложность (бинарный поиск, поиск в сбалансированном дереве)

3. **В чем основное отличие линейного поиска от бинарного? Какие предварительные условия необходимы для выполнения бинарного поиска?**
    - Основное отличие: линейный поиск проверяет элементы последовательно, бинарный - делит область поиска пополам. Условия для бинарного поиска: массив должен быть отсортирован.

4. **Почему на практике время выполнения алгоритма может отличаться от теоретической оценки O-большое?**
    - Теоретическая оценка не учитывает: константные множители, особенности аппаратного обеспечения (кэширование, конвейеризация), влияние операционной системы, особенности реализации языка программирования.

5. **Как экспериментально подтвердить, что сложность алгоритма равна O(n) или O(log n)? Опишите план эксперимента.**
        1. Измерить время выполнения на наборах данных разного размера
        2. Построить график зависимости времени от размера данных
        3. В линейном масштабе O(n) даст прямую линию, O(log n) - логарифмическую кривую
        4. В логарифмическом масштабе O(n) даст линейный рост, O(log n) - медленный рост
---

## Приложения
- [Исходный код программы](./src/main.py)  
- [Результаты](./report/results.txt)  
- [Графики](./report/search_comparison.png)
