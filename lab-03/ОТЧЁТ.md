# Отчет по лабораторной работе №3
# Тема: Рекурсия

**Дата:** 2025-12-7
**Семестр:** 3 курс, 5 семестр  
**Группа:** ПИЖ-б-о-23-2(2) 
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Урусов Руслан Исламович


## Цель работы
Изучение методов рекурсивного решения задач, включая факториал, числа Фибоначчи, бинарный поиск, Ханойские башни, а также использование мемоизации для оптимизации рекурсивных алгоритмов.

---

## Теоретическая часть
*   **Рекурсия:** Процесс, при котором функция прямо или косвенно вызывает саму себя для решения задачи.
*   **Базовый случай (условие выхода):** Обязательное условие, которое прекращает рекурсивные вызовы и предотвращает зацикливание.
*   **Рекурсивный шаг:** Шаг, на котором задача разбивается на более простую подзадачу того же типа и производится рекурсивный вызов.
*   **Глубина рекурсии:** Количество вложенных вызовов функции. Ограничена размером стека вызовов.
*   **Стек вызовов (Call Stack):** Структура данных, которая хранит информацию о незавершенных вызовах функций (локальные переменные, адрес возврата).
*   **Мемоизация (Memoization):** Техника оптимизации, позволяющая избежать повторных вычислений результатов функций для одних и тех же входных данных путем сохранения ранее вычисленных результатов в кеше (например, в словаре).

---

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализован рекурсивный расчет факториала  
- [x] Задача 2: Реализован наивный и мемоизированный расчет чисел Фибоначчи  
- [x] Задача 3: Реализован рекурсивный бинарный поиск и Ханойские башни  
- [x] Задача 4: Проведен рекурсивный обход файловой системы и измерена максимальная глубина рекурсии  
- [x] Задача 5: Сравнена производительность наивной и мемоизированной рекурсии с построением графика  

---

### Ключевые фрагменты кода
```python
# Рекурсивный факториал
def factorial(n: int) -> int:
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

# Наивная рекурсия Фибоначчи
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# Мемоизированная Фибоначчи
def fib_memo(n: int, cache=None) -> int:
    if cache is None:
        cache = {}
    if n in cache:
        return cache[n]
    if n <= 1:
        cache[n] = n
    else:
        cache[n] = fib_memo(n - 1, cache) + fib_memo(n - 2, cache)
    return cache[n]

# Рекурсивный бинарный поиск
def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)

# Ханойские башни
def hanoi_tower(n, source, target, auxiliary):
    if n == 1:
        print(f"Переместить диск 1 с {source} → {target}")
        return
    hanoi_tower(n - 1, source, auxiliary, target)
    print(f"Переместить диск {n} с {source} → {target}")
    hanoi_tower(n - 1, auxiliary, target, source)
```

---

## Результаты выполнения

### Пример работы программы
```bash
Бинарный поиск:
Элемент 7 имеет индекс: 3

Ханойские башни (3 диска):
Диск 1 с A → C
Диск 2 с A → B
Диск 1 с C → B
Диск 3 с A → C
Диск 1 с B → A
Диск 2 с B → C
Диск 1 с A → C

Обход файловой системы (только до 2 уровней):
|-- fibonacci_plot.png
|-- report
    |-- fibonacci_plot.png
|-- src
    |-- memoization.py
    |-- recursion.py
    |-- recursion_tasks.py
|-- ОТЧЁТ.md

Измеряем максимальную глубину рекурсии для текущей структуры:
|-- fibonacci_plot.png
|-- report
    |-- fibonacci_plot.png
|-- src
    |-- memoization.py
    |-- recursion.py
    |-- recursion_tasks.py
|-- ОТЧЁТ.md

Максимальная глубина рекурсии: 2

Сравнение времени выполнения рекурсии с мемоизацией и без:
Наивная рекурсия (35): 0.9569 сек
С мемоизацией (35): 0.0001 сек

```

---

### Характеристики ПК для тестирования
```
    Характеристики ПК для тестирования:
    - Процессор: AMD Ryzen 5 3600 6-core Processor 3.60 GHz
    - Оперативная память: 16 GB DDR4
    - ОС: Windows 10 PRO
    - Python: 3.11
```

## Выводы
1. Рекурсия удобна для решения задач с повторяющейся структурой, но может быть ресурсоёмкой.  
2. Мемоизация значительно ускоряет вычисления, особенно для экспоненциальных рекурсий, таких как числа Фибоначчи.  
3. Рекурсивные алгоритмы позволяют наглядно решать задачи бинарного поиска, Ханойских башен и обхода файловой системы, с измерением глубины рекурсии.

---

## Ответы на контрольные вопросы
1. **Что такое базовый случай и рекурсивный шаг в рекурсивной функции? Почему отсутствие базового случая приводит к ошибке?** - Базовый случай определяет условие, при котором рекурсия завершится, а рекурсивный шаг — это правило, по которому функция вызывает сама себя с уменьшенным или изменённым аргументом. Отсутствие базового случая приводит к бесконечной рекурсии и ошибке переполнения стека.

2. **Объясните, как работает механизм мемоизации. Как он меняет временную сложность вычисления чисел Фибоначчи по сравнению с наивной рекурсией?** - Мемоизация сохраняет ранее вычисленные значения в кэше, чтобы повторно их не вычислять. Для чисел Фибоначчи это снижает временную сложность с O(2^n) до O(n).

3. **В чем заключается основная проблема глубокой рекурсии и как она связана со стеком вызовов?** - Основная проблема глубокой рекурсии заключается в возможном переполнении стека вызовов (stack overflow). Каждый рекурсивный вызов сохраняет локальные переменные и адрес возврата в стеке, при глубокой рекурсии стек может исчерпать память.

4. **Задача о Ханойских башнях решается рекурсивно. Опишите алгоритм решения для 3 дисков.** - Перемещаем два верхних диска на вспомогательную башню, затем перемещаем самый большой диск на целевую башню, после чего два верхних диска с вспомогательной башни перемещаем на целевую башню.

5. **Рекурсивный и итеративный алгоритмы могут решать одни и те же задачи. Назовите преимущества и недостатки каждого подхода.** - Рекурсивный: преимущества — лаконичный и наглядный код; недостатки — большая нагрузка на стек, медленнее при больших данных. Итеративный: преимущества — экономичнее по памяти и быстрее; недостатки — код может быть более сложным и менее читаемым.

---

## Приложения
- [Исходный код recursion.py](./recursion.py)
- [Исходный код recursion_tasks.py](./recursion_tasks.py)
- [Исходный код memoization.py](./memoization.py)
![График сравнения времени вычислений Fibonacci](fibonacci_plot.png)